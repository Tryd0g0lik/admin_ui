## 1. Пользователь 
**Note**: *В силу ограниченных действий и событий образ пользователя собирается через* \
*"`Object`". ООП не используется.*


Любой пользователь попадая на страниу арр получает статус "`ANONYMOUSUSER`" и привелегии "`NoN`".\
```ts
import { UserPrivaleges, UserStatus, User } from "src/interfesaces";
{ // базовый user state.
  "email": "",
  "password": "",
  "status": UserStatus.STATUS_ANONYMOUSUSER,
  "privaleges": [UserPrivaleges.PRIVALEGES_ANONYMOUS],
  "token": ""
}
```
В данный момент, логика приложения основывается на таких свойствах как:\
- "`email`";
- "`password`";
- "`status`";
- "`privaleges`".

**Note**: *"`password`", "`email`" для передачи данных при событии GENERATE-запроса на сервер*.\
*Затем - пустая строка*.

"`status`" и "`privaleges`" регулируют уровень доступа и отобращаемого контента на странице.

**Например**, *если статут не является "`ANONYMOUSUSER`" , то открывается дополнительный раздел в верхнем меню, с его подразделами*.

**Подробнее** *о статусах и привелегиях пользователя "`src\interfesaces.ts`".*

### 1.2 CACH
1. Состояние образа пользователя сохраняется в "`localStorage`" с ключем "`user`".\
Данный  cach - востанавливает REDUX при событиях - перезагрузка и прочие перезагрузки страниц. \
"`src\reduxes\features\userstate\userSlice.ts`"

2. Токены сохраняем в "`Cookie`".

На этапе загрузки страницы , проверяем "`cookie`" и "`LS`". \
"`src\reduxes\features\userstate\userSlice.ts`"\
В приоритете проверки "`cookie`" и если токен не находим, удаляем "`LS`". Пользователь получает \
статус "`ANONYMOUSUSER`", дополнительно чистим REDUX.

### 1.2.1 CAHE POSTS
Для примера , на странице \
"`src\components\Posts\handlers\handlerRequest.ts`"\
можно использовать "`useMemo`" от React - Все посты хранить в кеше и не делать лишние запросы на сервер.\
Например, отслеживать "`url-пагинацию`" и "`токен`".\
```ts
const memoizedPosts = useMemo(() => {
  return requestJWTGet(url, Object.values(getToken)[0]);
}, [url, getToken]);
```
Первичный запрос постов - создаем кеш. В последющих данные берем из кеша, пока не заметим изменения в переменных "`url, getToken`".

Кеш не сделал, момент в том - как отследить редактирование поста, причем ДО запроса не сервер. 

## 2. UI
Клик по кнопке "`Вход`" открывает модальное окно с формой.\
"`src\components\InSideForm\index.tsx`"

1. Форма имеет свои регулярные выражения, в качестве шаблона для проверки контента формы.\
Заполняем поля, событие с клавишей "`Enter`" из поля ("`<input>`') вызывает проверку и публикует/удаляет ообщения об ошибке.

Всплываюшее описание  \
![Сообщение об ошибках в форме](./img//error_message_of_form.png)

Если форма заполнена корректно то отправляем запросы на сервер.\
"`src\components\NavBar\hamdlers`".

2. Текст кнопки "`Вход`", при изменении статуса "`ANONYMOUSUSER`" на любой другой статус, \
меняет на "`Выход`".

3. Наличие, на кнопке теста "`Выход`" не позволяет повторно вызывать форму активации. 
4. Клик по кнопке с текстом "`Выход`" чистит "`cookie`" и "`localStorage`", затем перекидывает пользователя на главную.\
Пользователь вновь получает статус "`ANONYMOUSUSER`". 

### 2.1 "Посты" Получить список постов
**Note:** 
- *Возможно, логика (которая закладывалась при создании задачи - получения списка постов) не совпадает с тем , что реализовано в данном app*.
- *Не совсем понял логику которая закладывалась в срок жизни токенов. Вроде 20 дней, исходя из милисекунд полученых при авторизации. Но запрос на обновление отправлять приходится чаще*.\
Но спрашивать/уточнять нет возможности.

Список постов возможно получить только если:
- статус пользователя не является "`ANONYMOUSUSER`";
- "`access_token`" токен рабочий;
- если "`access_token`" не действующий, пользователь имеет три попытки - обновить "`access_token`" используя "`refresh_token`". Пользователю, не требуется совершать проверки и отправки запросов на сервер (все под капотом).\
Если ТРИ запроса не удачные, пользователь остается авторизованным, но в консоле мошно прочитать ошибки. \
"`src\components\Posts\handlers\handlerRequest.ts`"

### 2.2 # Теги (под постом)
![Пост](./img/tags.png)

- Первичный клик по одному из тегов, совершает фильтрацию постов. Результат события - публикация списока постов (после клика по тегу) владеющие одноименным тегом.
- Последующие клики (по тегам), будут возвращать результат филтрации из предыдущего отфилдьтрованного контента.


- Клик по тегу переименовывает кнопку. Из "`Загрузить`" в "`Сбросить`".
- Клик по кнопке "`Сбросить`" - возвращает (на страницу) первоначальный контент. После возможно заново проводить клики по тегам. 
- Кнопка "Сбросить" на проводить запросы на сервер. Первоначальный контент храниться у пользователя в браузере ("`new Map()`"). 
- "`new Map()`" обнуляется после клика по "`Сбросить`".

**Note:** *Первичная загруз контента проводится по событию клика, по кнопке "`Загрузить`".*\
*Первичный контент возможно было бы подать событию загрузки страницы. Но в рамках данной задачи, решил применить "`Загрузить`"*.

"`src\components\Posts\index.tsx`".

### 2.2 Пагинация
Совершая запрос на сервер ("`pathname=/manage/posts`"), получаю ответ (браузер)"\
![DevTolse Request Headers](./img/post_response-request.png)

Но запрос "`response.headers.get(...);`" возвращает "`null`".\
Как вариант, браузер не даст доступ к ключу "`Link`", он не указан в "`Access-Control-Expose-Headers`".\

Просьба добаить "`Link`" в "`Access-Control-Expose-Headers`"

```http
Access-Control-Expose-Headers: X-Pagination-Current-Page, X-Pagination-Page-Count, X-Pagination-Per-Page, X-Pagination-Total-Count, Link
```

## 3. Комментарии

"Auth", исходя из описания - просто авторизация, а "Profile" вероятно переходим на страницу пользователя.\
Ошибку "`CORS`" исправило удаление "`headers`" из настройки запроса (что оказалось не тепичным для меня совершая POST запрос).
